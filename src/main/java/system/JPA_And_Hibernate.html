<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JPA_Hibernate</title>
</head>
<body>
<p>
    В данном документе буду систематизировать полученные знания в процессе прочтения документации по JPA и Hibernate.
    Буду записывать свои мысли на этот счет и в процессе изучения править их, ведь в таком потоке информации понять что-то не правильно довольно легко.
    Обучение буду строить в таком ключе: пишу программу bablo, натыкаюсь на непонимание того как это сделать и лезу в документацию. Описываю полученные
    знания здесь, а навыки проверяю в коде. Путь вырисовывается долгий, но надеюсь окупить это качеством знания. Как бы отследить изменения во времени?
    <!--TODO Для этого идеально подходит git! Поэтому сегодня обязательно сегодня претворить это в жизнь и взять в привычку коммитить изменения пару раз в день!-->
    http://download.oracle.com/otn-pub/jcp/persistence-2_2-mrel-eval-spec/JavaPersistence.pdf?AuthParam=1507790082_e54d15e61ce421b98f9b7ebd7668dbb8
    https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#preface
    <!--TODO Ссылки на документацию привязать к словам JPA и Hibernate-->
</p>
<p>
    Коротко о том что такое JPA. Это API предназначенное для работы с persistence data. Под последним я понимаю долгосрочно хранящиеся данные.
    Пусть они хранятся в базе данных. Hibernate, в свою очередь, является фреймворком для работы с этими данными, при этом работает он с ними
    через ORM. Последнее я понимаю как представление данных из БД в виде объектов, с которыми будет работать java приложение.
    Так, еще я считаю важным понимание того, что Hibernate это реализация спецификации JPA, т.е. JPA описавает как это должно работать, а
    Hibernate это описание претворяет в жизнь.
    <!--TODO Сделать ссылку на ORM-->

    <h2>Domain Model.</h2>
    <div>
    Модель области определения. Это сеть взаимосвязанных объектов, при этом каждый объект определяет отдельную сущность.
    Это центральное понятие в ORM. Составляет классы, которые мы хотим связать с БД. Другим важнейшим понятием является понимание
        слова mapping. Оно означает "связь", а понимается как преобразование Java-типов(примитивы и объекты) в типы СУБД и обратно.
        <div>
            <h3>Mapping types.</h3>
            В этой главе описываются виды связей. Я же хочу получить от нее ответы на следущие вопросы:
            1) Какие виды связей есть, в чем их отличие?
            2) Как мне организовать описание сущности в конкретной domain model БД bablo?
            3) Как мне быстро найти информацию по появившемуся вопросу?
            4) Что такое @Embeddable
            <p>
                1) В широком смысле связи делятся на два два вида:
                Value types - это состояния Entity. Называются еще persistent attribute. Не могут существовать сами по себе без entity
                Entity types - а это уже сами сущности, независимы от других объектов.
                    <h4>Value types</h4>
                    <p>
                        Делятся на три вида:
                        @Basic types - обычно маппит одну колонку таблицы БД к одиночному, не агрегированному Java-типу
                        Все эти типы приведены в таблицы ниже. Также там же расписано опциональные штуки при маппинге
                        https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#basic
                        @Embeddable types - встраиваемые типы. Тут все понятно, а главное это дало мне понимание отличия Value types от
                        Entity types. Вообще эти штуки удобны для разбиения таблицы на разные классы, которыми нам проще управлять с точки зрения ООП.
                        При работе с множественными
                        Перегрузка Embeddable types. JPA определяет аннотацию @AttributeOverride и @AssociationOverride

                        Collections
                    </p>
            </p>
        </div>
    </div>


    Приведу основные понятия используемые в JPA:
    Entity - в переводе на русский - сущность. Понимаю это как ORM представление некоторой таблицы БД. Некоторый класс, имеющий поля отображающие(здесь
    должно быть волшебное слово mapping) колонки в таблице(Конечно же это не так в реальном мире,  потому что архитектура таблицы может быть такой, что в ней одной
    хранятся данные из абсолютно разных областей, но для меня это не важно сейчас).
    В гайде к хибернейту дано следующее определение:
    <!--TODO Что это за актуальная поебень?-->
    Entity описывает связь между объектом актуальной персистентной доменной модели(ШТА?) и записями в таблицы базы данных.

    Mapping the Entity.
    @Entity(name = "Cost")          //Атрибут name опционален, при его отстутсвии будет использоваться имя класса.
    public static class Cost {
        @Id                         //Аннотация, связывающая поле id с уникальным идентификатором каждой строки таблицы БД.
        private Long id;
        @Column(name = "comment")   //Аннотация опциональна, маппит поле объекта к столбцу таблицы БД
        private String comment;
        // И так далее, включая аксессоры


    В JPA имеются требования к Entity классам:
    <!--TODO Сделать нумерованный список ниже списком html-->
    1) Должны помечаться аннотацией @Entity или быть описаны в XML
    2) Не должны быть интерфейсом или enum
    3) Должны иметь public или protected конструктор без аргументов. Иметь дополнительные конструкторы с аргументами не возбраняется.
    4) Классы не должны быть помечены как final и не должны иметь финализированных полей или методов, которые участвуют в маппинге.
    5) Если инстанс @Entity класса передается по значению как отдельный объект, то он также должен быть Serializable.
    <!--TODO ссылку на описание интерфейса Serializable-->
    6) Поля @Entity классов должны быть напрямую доступны только методам этих же классов, другие классы могут изменять их только через методы класса @Entity(например getter)
    7) @Entity класс должен содержать первичный ключ по одному из полей(@id)
    8) Класс должен быть классом верхнего уровня(т.е. не быть внутренним классом).
    <!--TODO Для ключевых слов придумать тег и оформить его однообразно через css-->
    @Entity поддерживают наследование, полиморфичность ассоциаций и полиморфичность запросов. ЧТО ЭТО?

В отличие от JPA в Hibernate требования к @Entity поменьше:
<!--TODO Сделать нумерованный список-->
1) Конструктор также должен быть без аргументов, но помимио public и protected может быть еще и package visibility.
2) Класс не должен быть top-level, может быть внутренним
3) Технически Hibernate может работать с финализированным классом или классом содержащим финализированный аксессор, но это не лучшая идея,
потому что фреймворк не сможет генерировать прокси для ленивой загрузки(ЧТО ЭТО?).
4) Также не запрещается доступ к переменным объектам извне, но это тоже не лучшее решение.(ЧТО ЭТО?)

</p>

<h2>Связи между таблицами.</h2>
    <p>
    При сохранении классов в отдельных таблицах решением вопроса по сохранению связей между эими таблицами являются аннотации:
    @OneToOne
    Связь один к одному. Довольно редкая связь, образуется, когда ключевой столбец одной таблицы присутствует в другой.
    Используется для разделения данных по разным таблицам в целях безопасности.
    @OneToMany или @ManyToOne
    Связь один ко многим. Самая распространенная связь. Образуется если одной записи в одной таблицы соответствует несколько записей в другой.
    @ManyToMany
    Многие ко многим. По своей сути является двумя записями вида @OneToMany в обе стороны.

    Ну и напомню себе, что связи нужны не ради декорирования, в перую очередь они нужны для поддержания целостности БД.
    Недаром связи называют еще ограничениями.

    EntityManager - объект управляющий набором инстансов сущностей в одном Persistence Context с помощью своих методов(API).
    Сформулировал почти по научному, но как бы это сказать еще проще? Это Map, в котором ключами являются
    Что такое persistence context? Я спросил у гугла, но
    Persistence Context - это некоторая область, отделенная логически от остальной программы.

    , Transaction, JPQL, Criteria, Persistence Context
</p>
<p>
    <!--TODO Как сделать структуру документа такой чтобы было наглядно видно и JPA и его реализация в Hibernate???-->
</p>

<p>
    Как же составлять запросы к БД?
    JPA описывает способ написания запросов с помощью JPQL <!--TODO сделать ссылку на описание JPQL, HQL и Criteria -->
    Hibernate также поддержтвает свой язык запросов HQL, основанный на JPQL. При этом все запросы JPQL будут валидны как HQL запросы, но не наоборот.
    Что говорит нам всего лишь о том факте, что HQL использует какие-то свои фичи поверх стандарта JPQL.
    Еще одним способом обращения к БД является Criteria, которая раньше была фичей Hibernate, а сейчас отнесена к JPA.
    Также поддерживается старый добрый SQL. Пишем привычные нам запросы как String и передаем методу. <!--TODO указать метод создания native запросов SQL -->
    Надо разделить экран на три столбца и описать как создаются запросы на каждом из языков.
</p>

<p>
    Опишу все что понял из описания JPQL из JPA. (Chapter 4 Query Language)
    Делаю для того чтобы применить данные навыки в описании выборки всех записей из таблицы bablo, которые соответствуют следующему критерию:
    Сумма всех трат по всем категориям за предыдущий месяц, отсортированные по алфавиту.
    Во-первых, как бы я сделал такой запрос в чистом SQL:
    <!--TODO здесь написать запрос на чистом SQL-->
    А вот как он должен выглядеть на JPQL:
    <!--TODO Написать запрос на JPQL-->
</p>

<p>
    <!--TODO Вынести это в отдельный файл и запомнить где он хранится!!!-->
    Пошаговое создание git репозитория.
    Зашел в директорию проекта cd ~/Documents/project/MyMoney
    сделал git init
    Добавил все файлы в репозиторий git add *
    git commit -m 'Added all files'
    git remote add mymoney git@github.com:Nikitossh/mymoney.git
    ssh-keygen -t rsa -b 4096 -C "nikitossh@mail.ru"
    ssh-add ~/.ssh/id_rsa
    git pull -u mymoney master
    git push -u mymoney master
</p>

</body>
</html>