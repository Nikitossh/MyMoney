<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JPA_Hibernate</title>
</head>
<body>
<p>
    В данном документе буду систематизировать полученные знания в процессе прочтения документации по JPA и Hibernate.
    Буду записывать свои мысли на этот счет и в процессе изучения править их, ведь в таком потоке информации понять что-то не правильно довольно легко.
    Обучение буду строить в таком ключе: пишу программу bablo, натыкаюсь на непонимание того как это сделать и лезу в документацию. Описываю полученные
    знания здесь, а навыки проверяю в коде. Путь вырисовывается долгий, но надеюсь окупить это качеством знания. Как бы отследить изменения во времени?
    <!--TODO Для этого идеально подходит git! Поэтому сегодня обязательно сегодня претворить это в жизнь и взять в привычку коммитить изменения пару раз в день!-->
    http://download.oracle.com/otn-pub/jcp/persistence-2_2-mrel-eval-spec/JavaPersistence.pdf?AuthParam=1507790082_e54d15e61ce421b98f9b7ebd7668dbb8
    https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#preface
    <!--TODO Ссылки на документацию привязать к словам JPA и Hibernate-->
</p>
<p>
    Коротко о том что такое JPA. Это API предназначенное для работы с persistence data. Под последним я понимаю долгосрочно хранящиеся данные.
    Пусть они хранятся в базе данных. Hibernate, в свою очередь, является фреймворком для работы с этими данными, при этом работает он с ними
    через ORM. Последнее я понимаю как представление данных из БД в виде объектов, с которыми будет работать java приложение.
    Так, еще я считаю важным понимание того, что Hibernate это реализация спецификации JPA, т.е. JPA описавает как это должно работать, а
    Hibernate это описание претворяет в жизнь.
    <!--TODO Сделать ссылку на ORM-->

    <h2>Domain Model.</h2>
    <div>
    Модель области определения. Это сеть взаимосвязанных объектов, при этом каждый объект определяет отдельную сущность.
    Это центральное понятие в ORM. Составляет классы, которые мы хотим связать с БД. Другим важнейшим понятием является понимание
        слова mapping. Оно означает "связь", а понимается как преобразование Java-типов(примитивы и объекты) в типы СУБД и обратно.
        <div>
            <h3>Mapping types.</h3>
            В этой главе описываются виды связей. Я же хочу получить от нее ответы на следущие вопросы:
            1) Какие виды связей есть, в чем их отличие?
            2) Как мне организовать описание сущности в конкретной domain model БД bablo?
            3) Как мне быстро найти информацию по появившемуся вопросу?
            <div>Ответы:
                1) В широком смысле связи делятся на два два вида:
                Value types - это состояния Entity. Называются еще persistent attribute. Не могут существовать сами по себе без entity
                Entity types - а это уже сами сущности, независимы от других объектов.
                    <h4>Value types</h4>

                        Делятся на три вида:
                        <strong>@Basic types</strong> - обычно маппит одну колонку таблицы БД к одиночному, не агрегированному Java-типу
                        Все эти типы приведены в таблицы ниже. Также там же расписано опциональные штуки при маппинге
                        https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#basic
                        <strong>@Embeddable types</strong> - встраиваемые типы. Тут все понятно, а главное это дало мне понимание отличия Value types от
                        Entity types. Вообще эти штуки удобны для разбиения таблицы на разные классы, которыми нам проще управлять с точки зрения ООП.
                        При работе с множественными embeddable types возникает непонятка при маппинге. Это описано здесь, но на практике я не применял:
                        аннотацию @AttributeOverride и @AssociationOverride
                        https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#embeddable-override
                        <strong>Collections</strong>

                    <h4>Entity types.</h4>
                    <p>
                        Очень много букофф и переписывать сюда оф руководство не буду. Отмечу что необходимо бы разобраться зачем нужны аннотации
                        @Subselect, @Tuplizer, @Proxy and @Synchronized
                    </p>
                2) Организовал разделив по класса Date, Category, Cost, Budget и описав через @ManyToOne
                3) https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#domain-model
            </div>
        </div>
    </div>



    Приведу основные понятия используемые в JPA:
    Entity - в переводе на русский - сущность. Понимаю это как ORM представление некоторой таблицы БД. Некоторый класс, имеющий поля отображающие(здесь
    должно быть волшебное слово mapping) колонки в таблице(Конечно же это не так в реальном мире,  потому что архитектура таблицы может быть такой, что в ней одной
    хранятся данные из абсолютно разных областей, но для меня это не важно сейчас).
    В гайде к хибернейту дано следующее определение:
    <!--TODO Что это за актуальная поебень?-->
    Entity описывает связь между объектом актуальной персистентной доменной модели(ШТА?) и записями в таблицы базы данных.

    Mapping the Entity.
    @Entity(name = "Cost")          //Атрибут name опционален, при его отстутсвии будет использоваться имя класса.
    public static class Cost {
        @Id                         //Аннотация, связывающая поле id с уникальным идентификатором каждой строки таблицы БД.
        private Long id;
        @Column(name = "comment")   //Аннотация опциональна, маппит поле объекта к столбцу таблицы БД
        private String comment;
        // И так далее, включая аксессоры


    В JPA имеются требования к Entity классам:
    <!--TODO Сделать нумерованный список ниже списком html-->
    1) Должны помечаться аннотацией @Entity или быть описаны в XML
    2) Не должны быть интерфейсом или enum
    3) Должны иметь public или protected конструктор без аргументов. Иметь дополнительные конструкторы с аргументами не возбраняется.
    4) Классы не должны быть помечены как final и не должны иметь финализированных полей или методов, которые участвуют в маппинге.
    5) Если инстанс @Entity класса передается по значению как отдельный объект, то он также должен быть Serializable.
    <!--TODO ссылку на описание интерфейса Serializable-->
    6) Поля @Entity классов должны быть напрямую доступны только методам этих же классов, другие классы могут изменять их только через методы класса @Entity(например getter)
    7) @Entity класс должен содержать первичный ключ по одному из полей(@id)
    8) Класс должен быть классом верхнего уровня(т.е. не быть внутренним классом).
    <!--TODO Для ключевых слов придумать тег и оформить его однообразно через css-->
    @Entity поддерживают наследование, полиморфичность ассоциаций и полиморфичность запросов. ЧТО ЭТО?

В отличие от JPA в Hibernate требования к @Entity поменьше:
<!--TODO Сделать нумерованный список-->
1) Конструктор также должен быть без аргументов, но помимио public и protected может быть еще и package visibility.
2) Класс не должен быть top-level, может быть внутренним
3) Технически Hibernate может работать с финализированным классом или классом содержащим финализированный аксессор, но это не лучшая идея,
потому что фреймворк не сможет генерировать прокси для ленивой загрузки(ЧТО ЭТО?).
4) Также не запрещается доступ к переменным объектам извне, но это тоже не лучшее решение.(ЧТО ЭТО?)

</p>

<h2>Связи между таблицами.</h2>
    <p>
    При сохранении классов в отдельных таблицах решением вопроса по сохранению связей между эими таблицами являются аннотации:
    @OneToOne
    Связь один к одному. Довольно редкая связь, образуется, когда ключевой столбец одной таблицы присутствует в другой.
    Используется для разделения данных по разным таблицам в целях безопасности.
    @OneToMany или @ManyToOne
    Связь один ко многим. Самая распространенная связь. Образуется если одной записи в одной таблицы соответствует несколько записей в другой.
    @ManyToMany
    Многие ко многим. По своей сути является двумя записями вида @OneToMany в обе стороны.

    Ну и напомню себе, что связи нужны не ради декорирования, в перую очередь они нужны для поддержания целостности БД.
    Недаром связи называют еще ограничениями.

    EntityManager - объект управляющий набором инстансов сущностей в одном Persistence Context с помощью своих методов(API).
    Сформулировал почти по научному, но как бы это сказать еще проще? Это Map, в котором ключами являются
    Что такое persistence context? Я спросил у гугла, но
    Persistence Context - это некоторая область, отделенная логически от остальной программы.

    , Transaction, JPQL, Criteria, Persistence Context
</p>
<p>
    <!--TODO Как сделать структуру документа такой чтобы было наглядно видно и JPA и его реализация в Hibernate???-->
</p>

<p>
    Как же составлять запросы к БД?
    JPA описывает способ написания запросов с помощью JPQL <!--TODO сделать ссылку на описание JPQL, HQL и Criteria -->
    Hibernate также поддержтвает свой язык запросов HQL, основанный на JPQL. При этом все запросы JPQL будут валидны как HQL запросы, но не наоборот.
    Что говорит нам всего лишь о том факте, что HQL использует какие-то свои фичи поверх стандарта JPQL.
    Еще одним способом обращения к БД является Criteria, которая раньше была фичей Hibernate, а сейчас отнесена к JPA.
    Также поддерживается старый добрый SQL. Пишем привычные нам запросы как String и передаем методу. <!--TODO указать метод создания native запросов SQL -->
    Надо разделить экран на три столбца и описать как создаются запросы на каждом из языков.
</p>

<p>
    Опишу все что понял из описания JPQL из JPA. (Chapter 4 Query Language)
    Делаю для того чтобы применить данные навыки в описании выборки всех записей из таблицы bablo, которые соответствуют следующему критерию:
    Сумма всех трат по всем категориям за предыдущий месяц, отсортированные по алфавиту.
    Во-первых, как бы я сделал такой запрос в чистом SQL:
    <!--TODO здесь написать запрос на чистом SQL-->
    А вот как он должен выглядеть на JPQL:
    <!--TODO Написать запрос на JPQL-->
</p>

<p>
    <!--TODO Вынести это в отдельный файл и запомнить где он хранится!!!-->
    <h3>Пошаговое создание git репозитория.</h3>
    Зашел в директорию проекта cd ~/Documents/project/MyMoney
    сделал git init
    Добавил все файлы в репозиторий git add *
    git commit -m 'Added all files'
    git remote add mymoney git@github.com:Nikitossh/mymoney.git
    ssh-keygen -t rsa -b 4096 -C "nikitossh@mail.ru"
    ssh-add ~/.ssh/id_rsa
    git pull -u mymoney master
    git push -u mymoney master

    <h3>Работа с ветками в Git</h3>
    git branch test         создание ветки test
    git branch -d test      удаление ветки test
    git checkout test       переключение на ветку
    git checkout -b t53     сокращенная запись двух верхних

    Для слияния переходим в ветку, в которую хотим слить изменения, затем сливаем из указанной ветки.
    git checkout master
    git merge test


</p>

<h5>13 ноября 2017 г.</h5>
Я убил таблицы со всеми данными. Есть бэкап, но данные там сильно протухли. Имеет смысл начинать сначала.
Хорошо, что сегодня я ввел все траты и вывел месячный отчет по ним. Это данные на 10 ноября по ноябрю.
Все остальные данные есть в файле. А я вернусь к записям в файлик ручками до конца месяца, выведу результаты и
начну все с начала. На этот раз продумаю ежедневный бэкап и слив его на github =) А пока надо восстановить старый бэкап
и с данными можно будет просто поиграться.
Текущие траты за этот месяц:
Категория			Сумма		Бюджет
------------------------------------------
alcohol				1495		2000
car					700			4000
communications		850			850
family				4020		3000
flat				2930		16500
food				4658		9000
health				382			2000
other				1115		2000
sport				12780		1000
------------------------------------------
Итого:				28930		0
В пятницу (10 ноября) я ушел с работы обескураженный тем, что умудрился запороть БД за 7 месяцев. Бэкап естественно давно уже протух.
Решил что раз уж это произошло, то надо менять подход к работе, настроить временные бэкапы и работать с тестовой БД. В то же время мне
удалось сохранить записи за этот месяц, поэтому смогу добавить актуальный отчет к уже существующим. Произошло данное действо, потому что
я решил разобраться с нерабочим тестом Cost2Test. В ходе гугления были выявлены ошибки несуществующего файла persistence.xml. Файл я создал.
Скопировал в него конфиг из интернета, поправил зависимость
<provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
И тест наконец-то запустился, но выдал мне красный цвет. Я пролистал дебаг и волосы на руках шевелнулись когда я читал слова
drop table costs, drop table budget, drop table date...
С затаившимся дыханием я залез в базу из консоли, написал show tables;
Увидел только category, заполненную 10 категориями и не имеющую уже никакой ценности. Повторный запуск теста уничтожил и ее.
Посидел погуглил что это может быть и нашел ответ:
<property name="hibernate.hbm2ddl.auto" value="create" />
Прочитал документацию и понял, что "create" здесь означает, что при создании EntityManagerFactory происходит создание схемы на основе @Entity и при этом
уничтожающей предыдущую схему. Закомментил строчку, но вот сегодня разобрался, что есть еще несколько значений в этом свойстве.
"validate" - проверяет схему, никаких изменений в БД. Проверил на этом, он ругнулся, что поле id в budget не совпадает. (smallint != bigint). Надо запомнить и поправить.
"update" - апдейтит схему. Куда и как не очень понятно. Щас запущу. В-общем что-то апдейтит и тест проходит. Надо будет вернуться к этому вопросу позже.
"create-drop" - дропает схему во время закрытия фабрики. Можно использовать для тестов и для временных БД.
Я подумал-подумал и закомментировал эту строчку. Тест проходит и отдает результаты! На шажок ближе!
Ну и наконец-то! Я поправил jsp и увидел на странице вывод. Поиграться с версткой, сделать чуть симпатичнее и готово!
На сегодня хватит.

<h5>14 ноября 2017г.</h5>
Создаю новую БД mybablo, со следующими таблицами:
// Создание БД
CREATE DATABASE mymoney;
// Таблица для ведения трат
CREATE TABLE cost (
id int(10) unsigned NOT NULL AUTO_INCREMENT,
value int(10) unsigned NOT NULL,
comment varchar(255) NOT NULL DEFAULT '',
date date NOT NULL DEFAULT '0000-00-00',
category_id smallint(3) NOT NULL,
PRIMARY KEY (id)
)
CHARACTER SET utf8
ENGINE=INNODB;
// Таблица с категориями трат
CREATE TABLE category (
id int(3) unsigned NOT NULL AUTO_INCREMENT,
category varchar(20) NOT NULL UNIQUE,
PRIMARY KEY (id)
)
CHARACTER SET utf8
ENGINE=INNODB;

Создал, начал писать констрэйнт и понял, что все это мне сейчас не нужно!
Надо обдумать как и что делать, слишком расплывчато.
Пока же я вбил данные за этот месяц, вбил данные прошедших дней и имею актуальную инфу этого месяца.
На сегодня хватит.

<h5>23 ноября 2017г.</h5>
Рефакторил код, вел записи трат и читал литературу. Сильно с места не сдвинулся, но СДВИНУЛСЯ.
Выстроил список технологий для приложения: Hibernate, Spring, Vaadin. Последние два через REST


</body>
</html>