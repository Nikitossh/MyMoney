<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JPA_Hibernate</title>
</head>
<body>
<p>
    В данном документе буду систематизировать полученные знания в процессе прочтения документации по JPA и Hibernate.
    Буду записывать свои мысли на этот счет и в процессе изучения править их, ведь в таком потоке информации понять что-то не правильно довольно легко.
    Обучение буду строить в таком ключе: пишу программу bablo, натыкаюсь на непонимание того как это сделать и лезу в документацию. Описываю полученные
    знания здесь, а навыки проверяю в коде. Путь вырисовывается долгий, но надеюсь окупить это качеством знания. Как бы отследить изменения во времени?
    <!--TODO Для этого идеально подходит git! Поэтому сегодня обязательно сегодня претворить это в жизнь и взять в привычку коммитить изменения пару раз в день!-->
    http://download.oracle.com/otn-pub/jcp/persistence-2_2-mrel-eval-spec/JavaPersistence.pdf?AuthParam=1507790082_e54d15e61ce421b98f9b7ebd7668dbb8
    https://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#preface
    <!--TODO Ссылки на документацию привязать к словам JPA и Hibernate-->
</p>
<p>
    Коротко о том что такое JPA. Это API предназначенное для работы с persistence data. Под последним я понимаю долгосрочно хранящиеся данные.
    Пусть они хранятся в базе данных. Hibernate, в свою очередь, является фреймворком для работы с этими данными, при этом работает он с ними
    через ORM. Последнее я понимаю как представление данных из БД в виде объектов, с которыми будет работать java приложение.
    Так, еще я считаю важным понимание того, что Hibernate это реализация спецификации JPA, т.е. JPA описавает как это должно работать, а
    Hibernate это описание претворяет в жизнь.
    <!--TODO Сделать ссылку на ORM-->

    Приведу основные понятия используемые в JPA:
    Entity - в переводе на русский - сущность. Понимаю это как ORM представление некоторой таблицы БД. Некоторый класс, имеющий поля отображающие(здесь
    должно быть волшебное слово mapping) колонки в таблице(Конечно же это не так в реальном мире,  потому что архитектура таблицы может быть такой, что в ней одной
    хранятся данные из абсолютно разных областей, но для меня это не важно сейчас).
    В гайде к хибернейту дано следующее определение:
    <!--TODO Что это за актуальная поебень?-->
    Entity описывает связь между объектом актуальной персистентной доменной модели(ШТА?) и записями в таблицы базы данных.
    В отличие от JPA в Hibernate требования к @Entity поменьше:
    <!--TODO Сделать нумерованный список-->
    1) Конструктор также должен быть без аргументов, но помимио public и protected может быть еще и package visibility.
    2) Класс не должен быть top-level, может быть внутренним
    3) Технически Hibernate может работать с финализированным классом или классом содержащим финализированный аксессор, но это не лучшая идея,
    потому что фреймворк не сможет генерировать прокси для ленивой загрузки(ЧТО ЭТО?).
    4) Также не запрещается доступ к переменным объектам извне, но это тоже не лучшее решение.(ЧТО ЭТО?)

    Mapping the Entity.
    @Entity(name = "Cost")          //Атрибут name опционален, при его отстутсвии будет использоваться имя класса.
    public static class Cost {
        @Id                         //Аннотация, связывающая поле id с уникальным идентификатором каждой строки таблицы БД.
        private Long id;
        @Column(name = "comment")   //Аннотация опциональна, маппит поле объекта к столбцу таблицы БД
        private String comment;
        // И так далее, включая аксессоры


    В JPA имеются требования к Entity классам:
    <!--TODO Сделать нумерованный список ниже списком html-->
    1) Должны помечаться аннотацией @Entity или быть описаны в XML
    2) Не должны быть интерфейсом или enum
    3) Должны иметь public или protected конструктор без аргументов. Иметь дополнительные конструкторы с аргументами не возбраняется.
    4) Классы не должны быть помечены как final и не должны иметь финализированных полей или методов, которые участвуют в маппинге.
    5) Если инстанс @Entity класса передается по значению как отдельный объект, то он также должен быть Serializable.
    <!--TODO ссылку на описание интерфейса Serializable-->
    6) Поля @Entity классов должны быть напрямую доступны только методам этих же классов, другие классы могут изменять их только через методы класса @Entity(например getter)
    7) @Entity класс должен содержать первичный ключ по одному из полей(@id)
    8) Класс должен быть классом верхнего уровня(т.е. не быть внутренним классом).
    <!--TODO Для ключевых слов придумать тег и оформить его однообразно через css-->
    @Entity поддерживают наследование, полиморфичность ассоциаций и полиморфичность запросов. ЧТО ЭТО?

    EntityManager - объект управляющий набором инстансов сущностей в одном Persistence Context с помощью своих методов(API).
    Сформулировал почти по научному, но как бы это сказать еще проще? Это Map, в котором ключами являются
    Что такое persistence context? Я спросил у гугла, но
    Persistence Context - это некоторая область, отделенная логически от остальной программы.

    , Transaction, JPQL, Criteria, Persistence Context
</p>
<p>
    <!--TODO Как сделать структуру документа такой чтобы было наглядно видно и JPA и его реализация в Hibernate???-->
</p>

<p>
    Как же составлять запросы к БД?
    JPA описывает способ написания запросов с помощью JPQL <!--TODO сделать ссылку на описание JPQL, HQL и Criteria -->
    Hibernate также поддержтвает свой язык запросов HQL, основанный на JPQL. При этом все запросы JPQL будут валидны как HQL запросы, но не наоборот.
    Что говорит нам всего лишь о том факте, что HQL использует какие-то свои фичи поверх стандарта JPQL.
    Еще одним способом обращения к БД является Criteria, которая раньше была фичей Hibernate, а сейчас отнесена к JPA.
    Также поддерживается старый добрый SQL. Пишем привычные нам запросы как String и передаем методу. <!--TODO указать метод создания native запросов SQL -->
    Надо разделить экран на три столбца и описать как создаются запросы на каждом из языков.
</p>

<p>
    Опишу все что понял из описания JPQL из JPA. (Chapter 4 Query Language)
    Делаю для того чтобы применить данные навыки в описании выборки всех записей из таблицы bablo, которые соответствуют следующему критерию:
    Сумма всех трат по всем категориям за предыдущий месяц, отсортированные по алфавиту.
    Во-первых, как бы я сделал такой запрос в чистом SQL:
    <!--TODO здесь написать запрос на чистом SQL-->
    А вот как он должен выглядеть на JPQL:
    <!--TODO Написать запрос на JPQL-->
</p>

<p>
    <!--TODO Вынести это в отдельный файл и запомнить где он хранится!!!-->
    Пошаговое создание git репозитория.
    Зашел в директорию проекта cd ~/Documents/project/MyMoney
    сделал git init
    Добавил все файлы в репозиторий git add *
    git commit -m 'Added all files'
    git remote add mymoney git@github.com:Nikitossh/mymoney.git
    ssh-keygen -t rsa -b 4096 -C "nikitossh@mail.ru"
    ssh-add ~/.ssh/id_rsa
    git pull -u mymoney master
    git push -u mymoney master
</p>

<h1>Задача №1</h1>
Создать запрос выводящий все траты за месяц по категориям. Вывести результат в браузер.
План:   1. Написать запрос.
        2. Получить данные и обработать их.
        3. Вывести эти данные в браузер.
Выполнение:
Запрос в чистом SQL будет выглядеть так:
SELECT category.category, SUM(costs.value) AS value
FROM costs
INNER JOIN category ON costs.category_id=category.id
INNER JOIN date ON costs.date_id=date.id
WHERE MONTH(date)=MONTH(NOW())
AND YEAR(date)=YEAR(NOW())
GROUP BY category;

Здесь я внезапно понял, что мне надо получить все объекты за месяц и потом уже работать с этими объектами.
А еще я понял, что намного проще писать простой SQL запрос. Итак, пишу нативный запрос и пробую получить данные.





</body>
</html>